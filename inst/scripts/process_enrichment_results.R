# Functions for processing enrichment results into consolidated format for Shiny app
# This script processes enrichment results generated by enrichment_analysis.R
# and creates a consolidated data file suitable for visualization

# Load required libraries with fallback
if (!requireNamespace("dplyr", quietly = TRUE)) {
  stop("dplyr package is required. Install with: install.packages('dplyr')")
}
library(dplyr)

# Load tidyr for pivot_wider
if (!requireNamespace("tidyr", quietly = TRUE)) {
  stop("tidyr package is required. Install with: install.packages('tidyr')")
}
library(tidyr)

# For bind_rows function
if (!exists("bind_rows")) {
  bind_rows <- function(...) {
    do.call(rbind, list(...))
  }
}

# For write_csv function
if (!requireNamespace("readr", quietly = TRUE)) {
  write_csv <- function(x, file) {
    write.csv(x, file, row.names = FALSE)
  }
} else {
  library(readr)
}

#' Extract enrichment data based on object type
#' 
#' Handles different enrichment result formats (GO, KEGG, Reactome, STRING, GSEA)
#' and extracts data into a standardized format
#'
#' @param obj The enrichment result object
#' @return A data frame with standardized columns
extract_enrichment_data <- function(obj) {
  tryCatch({
    # Handle different object types
    if (inherits(obj, "enrichResult")) {
      # Direct enrichResult object (GO, KEGG, Reactome, WikiPathways)
      result_df <- obj@result
      
      # Add enrichment type based on ontology if available
      if (length(obj@ontology) > 0) {
        result_df$enrichment_type <- paste0("GO_", obj@ontology)
      }
      return(result_df)
      
    } else if (is.list(obj) && "result" %in% names(obj)) {
      # List with result slot
      if (inherits(obj$result, "enrichResult")) {
        result_df <- obj$result@result
        if ("ONTOLOGY" %in% colnames(result_df)) {
          result_df$enrichment_type <- "Mixed"
        }
        return(result_df)
      }
      
    } else if (inherits(obj, "data.table") || inherits(obj, "data.frame")) {
      # Direct data.frame/data.table (GSEA)
      result_df <- as.data.frame(obj)
      
      # Convert GSEA format to standard format
      if (all(c("pathway", "padj", "NES") %in% colnames(result_df))) {
        result_df <- result_df %>%
          dplyr::rename(
            ID = pathway,
            p.adjust = padj
          ) %>%
          dplyr::mutate(
            Description = ID,
            enrichment_type = "GSEA"
          )
      }
      return(result_df)
      
    } else if (is.list(obj) && "enrichment" %in% names(obj)) {
      # STRING format
      result_df <- obj$enrichment
      
      # Convert STRING format to standard format
      if (all(c("term", "fdr", "description") %in% colnames(result_df))) {
        result_df <- result_df %>%
          dplyr::rename(
            ID = term,
            p.adjust = fdr,
            Description = description
          ) %>%
          dplyr::mutate(enrichment_type = "STRING")
      }
      return(result_df)
    }
    
    NULL
  }, error = function(e) {
    NULL
  })
}

#' Extract direction from file path
#' 
#' Determines whether results are for UP, DOWN, or ALL regulated genes
#'
#' @param file_path Path to the enrichment result file
#' @return Character string: "UP", "DOWN", "ALL", or "RANKED"
extract_direction <- function(file_path) {
  if (grepl("_UP\\.rds$", file_path)) {
    return("UP")
  } else if (grepl("_DOWN\\.rds$", file_path)) {
    return("DOWN")
  } else if (grepl("_ALL\\.rds$", file_path)) {
    return("ALL")
  } else if (grepl("/GSEA/", file_path)) {
    # GSEA is always run on ranked lists (ALL genes)
    return("RANKED")
  } else {
    # Default to ALL if no pattern found
    return("ALL")
  }
}

#' Process a single enrichment result file
#' 
#' Reads an RDS file, extracts enrichment data, and adds metadata
#'
#' @param file_path Path to the RDS file
#' @param metadata List containing metadata fields
#' @param root_dir Root directory for calculating relative paths
#' @return Data frame with enrichment results and metadata
process_single_file <- function(file_path, metadata, root_dir) {
  tryCatch({
    obj <- readRDS(file_path)
    result_df <- extract_enrichment_data(obj)
    
    if (!is.null(result_df) && nrow(result_df) > 0) {
      # Add metadata
      for (col in names(metadata)) {
        result_df[[col]] <- metadata[[col]]
      }
      
      # Extract and add direction
      result_df$direction <- extract_direction(file_path)
      
      # Determine enrichment category from file path if not already set
      if (!"enrichment_type" %in% colnames(result_df) || 
          all(result_df$enrichment_type %in% c("Mixed", NA))) {
        
        # Extract enrichment type from path
        if (grepl("/GO_", file_path)) {
          if (grepl("/GO_ALL/", file_path)) {
            result_df$enrichment_type <- "GO_ALL"
          } else if (grepl("/GO_BP/", file_path)) {
            result_df$enrichment_type <- "GO_BP"
          } else if (grepl("/GO_CC/", file_path)) {
            result_df$enrichment_type <- "GO_CC"
          } else if (grepl("/GO_MF/", file_path)) {
            result_df$enrichment_type <- "GO_MF"
          } else {
            result_df$enrichment_type <- "GO"
          }
        } else if (grepl("/GSEA/", file_path)) {
          result_df$enrichment_type <- "GSEA"
          
          # Add GSEA subtype from path
          if (grepl("/GO_BP/", file_path)) {
            result_df$gsea_subtype <- "GO_BP"
          } else if (grepl("/GO_CC/", file_path)) {
            result_df$gsea_subtype <- "GO_CC"
          } else if (grepl("/GO_MF/", file_path)) {
            result_df$gsea_subtype <- "GO_MF"
          } else if (grepl("/Hallmark/", file_path)) {
            result_df$gsea_subtype <- "Hallmark"
          } else if (grepl("/KEGG/", file_path)) {
            result_df$gsea_subtype <- "KEGG"
          }
        } else if (grepl("/KEGG/", file_path)) {
          result_df$enrichment_type <- "KEGG"
        } else if (grepl("/Reactome/", file_path)) {
          result_df$enrichment_type <- "Reactome"
        } else if (grepl("/WikiPathways/", file_path)) {
          result_df$enrichment_type <- "WikiPathways"
        } else if (grepl("/STRING/", file_path)) {
          result_df$enrichment_type <- "STRING"
        }
      }
      
      # Add full file path (relative to root_dir)
      result_df$source_file <- sub(paste0("^", root_dir, "/"), "", file_path)
      
      # Filter by adjusted p-value if the column exists
      if ("p.adjust" %in% colnames(result_df)) {
        result_df <- result_df %>%
          dplyr::filter(p.adjust < 0.05)
      }
      
      return(result_df)
    }
    
    NULL
  }, error = function(e) {
    cat("Error processing file", file_path, ":", e$message, "\n")
    NULL
  })
}

#' Process enrichment results in batches
#' 
#' Main function to process all enrichment result files and create consolidated data
#'
#' @param root_dir Root directory containing enrichment results
#' @param batch_size Number of files to process at once
#' @param output_file Name of output RDS file
#' @return Data frame with all enrichment results
process_enrichment_results <- function(root_dir = "enrichment_results", 
                                     batch_size = 100,
                                     output_file = "all_enrichment_padj005_complete_with_direction.rds") {
  
  # Find all RDS files
  files <- list.files(root_dir, pattern = "\\.rds$", recursive = TRUE, full.names = TRUE)
  
  # Exclude metadata files
  files <- files[!grepl("analysis_metadata\\.rds|analysis_failed_metadata\\.rds", files)]
  
  message("Found ", length(files), " RDS files to process")
  
  # Process all files in batches
  all_results <- list()
  n_batches <- ceiling(length(files) / batch_size)
  
  for (batch in 1:n_batches) {
    start_idx <- (batch - 1) * batch_size + 1
    end_idx <- min(batch * batch_size, length(files))
    
    message("Processing batch ", batch, "/", n_batches, " (files ", start_idx, "-", end_idx, ")")
    
    batch_results <- list()
    
    for (i in start_idx:end_idx) {
      file_path <- files[i]
      
      # Extract metadata from path
      path_parts <- strsplit(file_path, "/")[[1]]
      
      # Determine if MAST or MixScale (now supports CRISPRa/CRISPRi subdirectories)
      method <- if ("MAST" %in% path_parts) {
        "MAST"
      } else if ("MixScale" %in% path_parts) {
        "MixScale"
      } else {
        "Unknown"
      }
      
      # Extract gene/mutation and cluster
      if (method == "MAST") {
        mutation_idx <- which(path_parts == "MAST") + 1
        mutation <- path_parts[mutation_idx]
        cluster <- path_parts[mutation_idx + 1]
        experiment <- path_parts[mutation_idx + 2]
      } else if (method == "MixScale") {
        mutation_idx <- which(path_parts == "MixScale") + 1
        mutation <- path_parts[mutation_idx]
        cluster <- path_parts[mutation_idx + 1]
        experiment <- path_parts[mutation_idx + 2]
        
        # Check for CRISPRa/CRISPRi subdirectory
        if (mutation %in% c("CRISPRa", "CRISPRi")) {
          modality <- mutation
          mutation <- path_parts[mutation_idx + 1]
          cluster <- path_parts[mutation_idx + 2]
          experiment <- path_parts[mutation_idx + 3]
          method <- paste0("MixScale_", modality)
        }
      } else {
        next
      }
      
      metadata <- list(
        method = method,
        mutation_perturbation = mutation,
        cluster = cluster,
        experiment = experiment
      )
      
      # Process file
      result <- process_single_file(file_path, metadata, root_dir)
      if (!is.null(result)) {
        batch_results[[length(batch_results) + 1]] <- result
      }
    }
    
    # Combine batch results
    if (length(batch_results) > 0) {
      batch_combined <- bind_rows(batch_results)
      all_results[[length(all_results) + 1]] <- batch_combined
      message("    Processed ", nrow(batch_combined), " significant terms")
      
      # Clear memory
      rm(batch_results, batch_combined)
      gc()
    }
  }
  
  # Combine all results
  message("\nCombining all results...")
  combined <- bind_rows(all_results)
  
  # Clean up column names
  cols_to_remove <- c("termsim", "method.1", "dr")
  cols_present <- cols_to_remove[cols_to_remove %in% colnames(combined)]
  if (length(cols_present) > 0) {
    combined <- combined[, !colnames(combined) %in% cols_present]
  }
  
  # Reorder columns
  col_order <- c("method", "mutation_perturbation", "cluster", "experiment", 
                 "enrichment_type", "direction", "ID", "Description")
  other_cols <- setdiff(colnames(combined), col_order)
  combined <- combined[, c(col_order, other_cols)]
  
  # Save results
  message("\nSaving combined results to ", output_file, "...")
  saveRDS(combined, output_file)
  
  # Create summary statistics
  summary_stats <- combined %>%
    dplyr::group_by(method, mutation_perturbation, cluster, experiment, enrichment_type, direction) %>%
    dplyr::summarise(
      n_terms = n(),
      .groups = "drop"
    )
  
  message("\nSummary statistics:")
  print(summary_stats)
  
  # Save summary
  write_csv(summary_stats, "enrichment_summary_stats.csv")
  
  # Direction distribution
  direction_summary <- combined %>%
    dplyr::group_by(enrichment_type, direction) %>%
    dplyr::summarise(
      n_terms = n(),
      .groups = "drop"
    ) %>%
    pivot_wider(names_from = direction, values_from = n_terms, values_fill = 0)
  
  message("\nDirection distribution by enrichment type:")
  print(direction_summary)
  
  message("\nProcessing complete!")
  message("Results saved to: ", output_file)
  
  return(combined)
}

# Example usage:
# results <- process_enrichment_results("enrichment_results")
# 
# Or with custom parameters:
# results <- process_enrichment_results(
#   root_dir = "enrichment_results_full",
#   batch_size = 50,
#   output_file = "consolidated_enrichment_data.rds"
# )